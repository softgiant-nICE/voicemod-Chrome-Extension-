{"version":3,"file":"injected.js","mappings":";;;;;;;;;;;;;;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrDwB;;AAET;AACf;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,IAAI;AACzC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,4CAAG;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,kDAAkD,eAAe;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;;AAEA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+CAA+C,KAAK;AACpD;;AAEA,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,iCAAiC;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,iCAAiC;AACrD;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,sCAAsC,kBAAkB;AACxD,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,sBAAsB,QAAQ;AAC9B,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;;AAEA,sBAAsB,8BAA8B;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,iCAAiC,oBAAoB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC/jBA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;UClBvB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNuC;AACE;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,2DAAI;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,uDAAuD,kBAAkB,cAAc;AACvF;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAsB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,qBAAqB;;AAE5F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC","sources":["webpack:///../node_modules/chromane/js/Log.js","webpack:///../node_modules/chromane/js/Util.js","webpack:///./js/classes/Helpers.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./js/entry/injected.js"],"sourcesContent":["export default class Log {\n  constructor(config) {\n    this.config = config;\n  }\n  write() {\n    if (this.config !== \"prod\") {\n      console.log(Array.from(arguments));\n    }\n  }\n  write_method_call({\n    obj,\n    class_name,\n    method_name,\n    args,\n    output,\n    error,\n    stub,\n    stack,\n    ignore,\n  }) {\n    if (!ignore && this.config !== \"prod\") {\n      let log_color = \"eggshell\";\n      if (stub) {\n        log_color = \"yellow\";\n      } else if (error) {\n        log_color = \"red\";\n      } else {\n        log_color = \"white\";\n      }\n\n      console.groupCollapsed(\n        \"%c \" + class_name + \".\" + method_name,\n        `color: ${log_color}`\n      );\n      console.log(\"this:\");\n      console.log(obj);\n      console.log(\"input:\");\n      for (var i = 0; i < args.length; i++) {\n        console.log(args[i]);\n      }\n      console.log(args);\n      console.log(\"output:\");\n      console.log(output);\n\n      if (error) {\n        console.log(stack);\n      }\n\n      console.groupEnd();\n    }\n  }\n  do_not_log() {}\n  do_log() {}\n}\n","import Log from \"./Log\";\n\nexport default class Util {\n  // dig\n  // utility function for finding strings in global variables\n  dig(seen_objects, path, src) {\n    seen_objects.add(src);\n    let keys = Object.keys(src);\n    for (let len = keys.length, i = 0; i < len; i++) {\n      let key = keys[i];\n      let v = src[key];\n      if (!v || seen_objects.has(v)) {\n        continue;\n      }\n      if (typeof v === \"string\") {\n        console.log(path.join(\".\"), key, v);\n      } else if (typeof v === \"object\") {\n        let new_path = JSON.parse(JSON.stringify(path));\n        new_path.push(key);\n        dig(seen_objects, new_path, v);\n      }\n    }\n  }\n\n  // !NOT FINISHED\n  detect_changes(target, interval, callback) {\n    let last_change_ts = 0;\n    let last_callback_call_ts = 0;\n    let observer = new MutationObserver(() => {\n      let now_ts = Date.now();\n      if (now_ts - last_change_ts > intervalc) {\n      }\n      last_change_ts = Date.now();\n    });\n    observer.observe(target, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n    });\n    setInterval(() => {}, interval);\n    callback();\n  }\n  //\n  inject_js() {\n    let script = document.createElement(\"script\");\n    script.src = chrome.runtime.getURL(\"/js/injected.js\");\n    document.documentElement.append(script);\n  }\n  async inject_css() {\n    var css = await this.fetch_text(this.get_url(\"/css/content.css\"));\n    document.documentElement.append(\n      this.html_to_element(`<style>${css}</style>`)\n    );\n  }\n  get_iframe_src() {\n    if (this.config.mode === \"dev\") {\n      return \"http://localhost:2010/\";\n    } else {\n      return chrome.runtime.getURL(\"/pages/app/index.html\");\n    }\n  }\n  find_text_input(element) {\n    let text_input = Array.from(\n      element.querySelectorAll(\"input, textarea\")\n    ).filter((input) => {\n      return (\n        input.type === \"text\" ||\n        input.type === \"textarea\" ||\n        input.type === \"number\" ||\n        input.type === \"email\"\n      );\n    })[0];\n    return text_input;\n  }\n  constructor(config) {\n    this.config = config;\n    this.log = new Log(config);\n  }\n  get_url(url) {\n    return chrome.runtime.getURL(url);\n  }\n  get_value(selector) {\n    let el = $(selector).get(0);\n\n    if (el) {\n      if (el.tagName === \"META\") {\n        return el.getAttribute(\"content\").trim();\n      } else {\n        return el.textContent.trim();\n      }\n    } else {\n      return \"Not available\";\n    }\n  }\n  async wait(time) {\n    return new Promise((resolve) => {\n      setTimeout(resolve, time);\n    });\n  }\n  decode_json(text) {\n    try {\n      return JSON.parse(text);\n    } catch (e) {\n      return null;\n    }\n  }\n  clone(obj) {\n    try {\n      return JSON.parse(JSON.stringify(obj));\n    } catch (e) {\n      return null;\n    }\n  }\n  is_undefined(value) {\n    return typeof value === \"undefined\";\n  }\n\n  list_is_empty(list) {\n    return list.length === 0;\n  }\n\n  object_is_empty(object) {\n    return Object.keys(object).length === 0;\n  }\n  async fetch_json(url, data) {\n    let r = await fetch(url, data);\n    let text = await r.text();\n    try {\n      return JSON.parse(text);\n    } catch (e) {\n      console.log(\"error\");\n      console.log(e);\n      return null;\n    }\n  }\n  async fetch_text(url) {\n    let r = await fetch(url);\n    let text = await r.text();\n    return text;\n  }\n  async wait_for_ready_state_complete() {\n    while (true) {\n      if (document.readyState === \"complete\") {\n        return;\n      } else {\n        await this.wait(200);\n      }\n    }\n  }\n  async wait_for_element(selector) {\n    for (let i = 0; i < 1000; i++) {\n      let element = document.querySelector(selector);\n      if (element) {\n        return element;\n      } else {\n        await this.wait(100);\n      }\n    }\n  }\n  simulate(element, event_name) {\n    element.dispatchEvent(new Event(event_name, { bubbles: true }));\n  }\n  html_to_element(html) {\n    // var doc = new DOMParser().parseFromString(html, \"text/html\");\n    // this.deps.log.write(\"doc\", doc);\n    // return doc.body.firstChild;\n\n    let div = document.createElement(\"div\");\n    div.innerHTML = html;\n    return div.firstElementChild;\n  }\n  // complex selectors\n  run_complex_selector(selector) {\n    // init root_element\n    if (selector.root_css) {\n      var root_element = document.querySelector(selector.root_css);\n\n      if (!root_element) {\n        root_element = document;\n      }\n    } else if (selector.root_element) {\n      var root_element = selector.root_element;\n    } else {\n      var root_element = document;\n    }\n\n    // this.deps.log.write(\"root_element\", root_element);\n\n    // init element_arr\n    if (selector.css) {\n      var element_arr = Array.from(root_element.querySelectorAll(selector.css));\n    } else {\n      var element_arr = Array.from(root_element.querySelectorAll(\"*\"));\n    }\n\n    // this.deps.log.write(\"element_arr\", element_arr);\n\n    // filter by inner_text\n\n    if (selector.inner_text) {\n      for (var i = element_arr.length; i--; ) {\n        if (element_arr[i].innerText !== selector.inner_text) {\n          element_arr.splice(i, 1);\n        }\n      }\n    }\n\n    if (selector.inner_text_includes) {\n      for (var i = element_arr.length; i--; ) {\n        if (\n          element_arr[i].innerText\n            .toLowerCase()\n            .includes(selector.inner_text_includes) === false\n        ) {\n          element_arr.splice(i, 1);\n        }\n      }\n    }\n\n    // filter by style\n    if (selector.style) {\n      var key_arr = Object.keys(selector.style);\n      var style = null;\n\n      loop_1: for (var i = element_arr.length; i--; ) {\n        style = window.getComputedStyle(element_arr[i]);\n\n        loop_2: for (var j = key_arr.length; j--; ) {\n          if (selector.style[key_arr[j]] !== style[key_arr[j]]) {\n            element_arr.splice(i, 1);\n            continue loop_1;\n          }\n        }\n      }\n    }\n\n    //filter by min_area\n    if (selector.min_area) {\n      for (let i = element_arr.length; i--; ) {\n        let rect = element_arr[i].getBoundingClientRect();\n        let area = rect.width * rect.height;\n        if (area < selector.min_area) {\n          element_arr.splice(i, 1);\n        }\n      }\n    }\n\n    // return\n    return element_arr;\n  }\n  find_element(complex_selector_arr) {\n    var element = null;\n\n    for (var i = 0; i < complex_selector_arr.length; i++) {\n      var element_arr = this.run_complex_selector(complex_selector_arr[i]);\n\n      if (element_arr && element_arr.length > 0) {\n        return element_arr[0];\n      }\n    }\n\n    return null;\n  }\n  find_elements(complex_selector_arr) {\n    var element = null;\n\n    for (var i = 0; i < complex_selector_arr.length; i++) {\n      var element_arr = this.run_complex_selector(complex_selector_arr[i]);\n\n      if (element_arr && element_arr.length > 0) {\n        return element_arr;\n      } else {\n        return [];\n      }\n    }\n\n    return null;\n  }\n  bg_fetch(url, data) {\n    return new Promise((r) => {\n      chrome.runtime.sendMessage(\n        {\n          name: \"fetch_json\",\n          data: { url, data },\n        },\n        (result) => {\n          r(result);\n        }\n      );\n    });\n  }\n  // window api\n  create_iframe_wrap(iframe) {\n    let promise = new Promise((r) => {\n      let listener = (event) => {\n        if (\n          event.data &&\n          event.data.name === \"iframe_ready\" &&\n          iframe.contentWindow === event.source\n        ) {\n          console.log(\"iframe_ready\", event.source);\n          let iframe_window = event.source;\n          window.removeEventListener(\"message\", listener);\n          r(this.create_window_wrap(window, iframe_window));\n        }\n      };\n      window.addEventListener(\"message\", listener);\n    });\n    return {\n      exec: (name, data) => {\n        return promise.then((wrap) => {\n          return wrap.exec(name, data);\n        });\n      },\n    };\n  }\n\n  create_window_wrap(window, target_window) {\n    //\n    let _resolvers = [];\n    window.addEventListener(\"message\", async (event) => {\n      if (event.data) {\n        let name = event.data.name;\n        let meta = event.data.meta;\n        let data = event.data.data;\n        if (\n          name === \"exec_result\" &&\n          meta &&\n          meta.response &&\n          _resolvers[meta.request_id]\n        ) {\n          _resolvers[meta.request_id](data.result);\n        }\n      }\n    });\n    return {\n      exec: (name, data) => {\n        return new Promise((r) => {\n          let request_id = _resolvers.length;\n          _resolvers.push(r);\n          let meta = { request_id, request: true };\n          target_window.postMessage({ name, meta, data }, \"*\");\n        });\n      },\n    };\n  }\n  create_window_api(methods) {\n    window.addEventListener(\"message\", async (event) => {\n      if (event.data) {\n        let name = event.data.name;\n        let meta = event.data.meta;\n        let data = event.data.data;\n        if (methods[name]) {\n          let result = await methods[name](data);\n          event.source.postMessage(\n            {\n              name: \"exec_result\",\n              meta: {\n                response: true,\n                request_id: meta,\n                request_id: meta.request_id,\n              },\n              data: { result },\n            },\n            \"*\"\n          );\n        }\n      }\n    });\n  }\n  // runtime api ( background )\n  create_runtime_api(methods) {\n    chrome.runtime.onMessage.addListener(function (message, sender, callback) {\n      console.log(methods, message);\n      if (methods[message.name]) {\n        if (message.data && message.data._sender) {\n          message.data._sender = sender;\n        }\n        methods[message.name](message.data).then(callback);\n      } else {\n        callback(null);\n      }\n      return true;\n    });\n  }\n  runtime_exec(name, data) {\n    return new Promise((resolve) => {\n      chrome.runtime.sendMessage(\n        {\n          name,\n          data,\n        },\n        resolve\n      );\n    });\n  }\n  // google sheets helper\n  parse_rows(rows) {\n    var data_arr = [];\n    var data = null;\n\n    // assume that the first row defines the property names of each object\n    var property_name_arr = rows[0];\n\n    for (var i = 1; i < rows.length; i++) {\n      data = {};\n\n      for (var j = 0; j < property_name_arr.length; j++) {\n        data[property_name_arr[j]] = rows[i][j];\n      }\n\n      data_arr.push(data);\n    }\n\n    return data_arr;\n  }\n  // class wrapper\n  get_methods(obj) {\n    return Object.getOwnPropertyNames(obj).filter((item) => {\n      return typeof obj[item] === \"function\";\n    });\n  }\n  wrap_class(item, ignore) {\n    ignore = ignore || [];\n    let util = this;\n    let class_name = item.name;\n    let methods = this.get_methods(item.prototype);\n    methods.forEach((method_name) => {\n      let original = item.prototype[method_name];\n      item.prototype[method_name] = function () {\n        let log = {\n          ignore: ignore.includes(method_name),\n          obj: this,\n          class_name,\n          method_name,\n          args: Array.from(arguments),\n        };\n        let stubs = util.stubs;\n        if (\n          stubs &&\n          stubs[0] &&\n          stubs[0].class_name === class_name &&\n          stubs[0].method_name === method_name\n        ) {\n          log.stub = true;\n          log.output = stubs[0].output;\n          stubs.splice(0, 1);\n          util.log.write_method_call(log);\n          return log.output;\n        } else {\n          try {\n            log.output = original.apply(this, arguments);\n          } catch (e) {\n            log.error = true;\n            log.stack = e.stack;\n            log.output = null;\n          }\n          if (log.output && log.output.then) {\n            log.output = new Promise((resolve) => {\n              log.output\n                .then((result) => {\n                  log.output = result;\n                  util.log.write_method_call(log);\n                  resolve(result);\n                })\n                .catch((e) => {\n                  log.error = true;\n                  log.stack = e.stack;\n                  log.output = null;\n                  util.log.write_method_call(log);\n                  resolve(null);\n                });\n            });\n          } else {\n            util.log.write_method_call(log);\n          }\n          return log.output;\n        }\n      };\n    });\n  }\n  set_stubs(stubs) {\n    this.stubs = stubs;\n  }\n  // Old Common\n  post_window_message(target, name, data) {\n    target.postMessage({ name, data }, \"*\");\n  }\n\n  blob_to_base64(blob) {\n    return new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        resolve(reader.result);\n      };\n      reader.readAsDataURL(blob);\n    });\n  }\n\n  download_string(str, name) {\n    var blob = new Blob([str], { type: \"text/plain\" });\n    var url = URL.createObjectURL(blob);\n    var a = document.createElement(\"a\");\n\n    document.body.appendChild(a);\n    a.style = \"display: none\";\n    a.href = url;\n    a.download = name;\n    a.click();\n\n    window.URL.revokeObjectURL(url);\n  }\n\n  download_blob(blob, name) {\n    var url = URL.createObjectURL(blob);\n    var a = document.createElement(\"a\");\n\n    document.body.appendChild(a);\n    a.style = \"display: none\";\n    a.href = url;\n    a.download = name;\n    a.click();\n    window.URL.revokeObjectURL(url);\n  }\n\n  find(arr, key, value) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i][key] === value) {\n        return arr[i];\n      }\n    }\n    return null;\n  }\n\n  update_object(object, new_object) {\n    Object.keys(new_object).forEach((key) => {\n      if (object[key] !== null && typeof object[key] === \"object\") {\n        this.update_object(object[key], new_object[key]);\n      } else {\n        object[key] = new_object[key];\n      }\n    });\n  }\n\n  rows_to_data_arr(rows) {\n    var data_arr = [];\n    var data = null;\n    // assume that the first row defines the property names of each object\n    var property_name_arr = rows[0];\n    for (var i = 1; i < rows.length; i++) {\n      data = {};\n      for (var j = 0; j < property_name_arr.length; j++) {\n        data[property_name_arr[j]] = rows[i][j];\n      }\n      data_arr.push(data);\n    }\n    return data_arr;\n  }\n\n  to_data_url(url) {\n    return new Promise((resolve) => {\n      var xhr = new XMLHttpRequest();\n      xhr.onload = function () {\n        var reader = new FileReader();\n        reader.onloadend = function () {\n          resolve(reader.result);\n        };\n        reader.readAsDataURL(xhr.response);\n      };\n\n      xhr.open(\"GET\", url);\n      xhr.responseType = \"blob\";\n      xhr.send();\n    });\n  }\n}\n","class Helpers {\n  timeout(ms) {\n    return new Promise((res) => {\n      setTimeout(() => {\n        res();\n      }, ms);\n    });\n  }\n\n  blob_to_base64(blob) {\n    return new Promise((resolve, _) => {\n      const reader = new FileReader();\n      reader.onloadend = () => resolve(reader.result);\n      reader.readAsDataURL(blob);\n    });\n  }\n}\nconst helpers = new Helpers();\nexport default helpers;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import Util from \"chromane/js/Util.js\";\nimport helpers from \"../classes/Helpers\";\n\n(async function () {\n  const real_getUserMedia = navigator.mediaDevices.getUserMedia;\n\n  const _state = {\n    // develope\n    is_with_api_fetch: true,\n    // production\n    is_first_record: true,\n    is_audio_record_start: false,\n    origin_audio_stream: null,\n    recorder_chuncks: [],\n    audio_recorder: null,\n    ac: null,\n    merger: null,\n    audio_node: null,\n    audio_stream: null,\n  };\n\n  window.util = new Util();\n  window.window_wrap = window.util.create_window_wrap(window, window.parent);\n\n  window.addEventListener(\"message\", (e) => {\n    const reason = e.data.reason;\n    const data = e.data.data;\n    if (reason === \"key_press\") {\n      start_record();\n    }\n    if (reason === \"key_up\") {\n      stop_record();\n    }\n  });\n\n  // !Main functionss ---------------------------------------------------------------\n\n  // Here we take chunks and generete our own audio element get stream from him and replace\n  //native track\n  async function replace_original_stream() {\n    const audio_recorder_stream = await get_audio_recorder_stream();\n    if (!_state.ac) {\n      _state.ac = new AudioContext();\n      _state.merger = _state.ac.createChannelMerger(2);\n    }\n\n    console.log(audio_recorder_stream, \"audio recorder stream\");\n\n    const node = _state.ac.createMediaStreamSource(audio_recorder_stream);\n    node.connect(_state.merger, 0, 1);\n  }\n\n  // !Media recorder managment------------------------------------\n  async function start_record() {\n    const media_stream = _state.origin_audio_stream;\n    if (!media_stream) return;\n\n    window.window_wrap.exec(\"start_record\");\n    const media_recorder = new MediaRecorder(media_stream);\n    media_recorder.ondataavailable = (e) => {\n      _state.recorder_chuncks.push(e.data);\n    };\n    media_recorder.onstop = onstop_handler;\n\n    _state.audio_recorder = media_recorder;\n\n    exec_mute_audio_during_record();\n    media_recorder.start();\n    _state.is_audio_record_start = true;\n  }\n\n  function stop_record() {\n    if (!_state.audio_recorder) return;\n    if (_state.audio_recorder.state === \"inactive\") return;\n    _state.audio_recorder.stop();\n  }\n\n  function onstop_handler() {\n    window.window_wrap.exec(\"generete_record\");\n    exec_unmute_audio_after_record_played();\n    replace_original_stream();\n  }\n\n  async function get_audio_recorder_stream() {\n    return new Promise(async (res) => {\n      const audio = new Audio();\n      audio.crossOrigin = \"anonymous\";\n      // audio.volume = 0.25;\n      // audio.volume = 1;\n      audio.type = \"audio/mp3\";\n\n      //!END OF RECORDING Played\n      audio.addEventListener(\"ended\", function () {\n        window.window_wrap.exec(\"stop_record_playing\");\n        audio.src = \"\";\n        audio.removeEventListener(\"ended\", this);\n        _state.is_audio_record_start = false;\n        _state.recorder_chuncks = [];\n        _state.audio_recorder = null;\n      });\n\n      // !RECORD START TO PLAY LISTENER\n      audio.addEventListener(\"canplaythrough\", async function () {\n        const audioContext = new AudioContext();\n        const mp3AudioSource = audioContext.createMediaElementSource(audio);\n        const mp3AudioDestination = audioContext.createMediaStreamDestination();\n        mp3AudioSource.connect(mp3AudioDestination);\n        audio.play();\n        window.window_wrap.exec(\"play_record\");\n        const stream = audio.captureStream();\n        audio.removeEventListener(\"canplaythrough\", this);\n        res(stream);\n      });\n      const blob = new Blob(_state.recorder_chuncks, { type: \"audio/ogg; codecs=opus\" });\n      const audio_url = await fetch_audio_url(blob);\n      audio.src = audio_url;\n    });\n  }\n\n  async function fetch_audio_url(blob) {\n    if (_state.is_first_record) {\n      const iframe = document.getElementById(\"soundboard-mini-popup\");\n      window.window_parent = await window.util.create_window_wrap(window, iframe.contentWindow);\n      _state.is_first_record = false;\n    }\n    const base64 = await helpers.blob_to_base64(blob);\n\n    const bg_response = await window.window_wrap.exec(\"fetch_voice\", base64);\n    console.log(bg_response);\n    //On zoom page return our downloaded base 64 url\n    // if (window.location.href.includes(\"www.zoom.\")) {\n    //   return bg_response;\n    // }\n    const new_blob = await window.window_parent.exec(\"fetch_base64\", { base64: bg_response });\n\n    const local_url = URL.createObjectURL(new_blob);\n\n    return local_url;\n  }\n\n  // !Audio mute handlers----------------------------------------------------\n  function mute_audio() {\n    if (!_state.origin_audio_stream) return;\n    _state.origin_audio_stream.getAudioTracks().forEach((track) => {\n      track.enabled = false;\n    });\n    console.log(\"Mute Origin audion stream\");\n  }\n\n  function exec_mute_audio_during_record() {\n    _state.audio_node.disconnect();\n    console.log(\"Disconnecttt\");\n  }\n\n  function exec_unmute_audio_after_record_played() {\n    if (!_state.audio_node) return;\n    _state.audio_node.connect(_state.merger, 0, 0);\n    console.log(\"Connect\");\n  }\n\n  // !OVERRIDER ---------------------------------------------------------------------------------------\n  navigator.mediaDevices.getUserMedia = async function (constraints) {\n    const original_stream = await real_getUserMedia.apply(this, arguments);\n\n    if (constraints.audio) {\n      const ac = new AudioContext();\n      _state.ac = ac;\n      const merger = ac.createChannelMerger(2);\n      _state.merger = merger;\n\n      _state.origin_audio_stream = original_stream;\n\n      const node = ac.createMediaStreamSource(original_stream);\n\n      node.connect(merger, 0, 0);\n\n      _state.audio_node = node;\n\n      const dest = ac.createMediaStreamDestination();\n\n      merger.connect(dest);\n\n      _state.audio_stream = dest.stream;\n      return dest.stream;\n    } else {\n      return original_stream;\n    }\n  };\n})();\n"],"names":[],"sourceRoot":""}